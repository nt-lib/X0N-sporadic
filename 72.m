/////////////////////////////////////////////////////////////////////
load "models_and_maps.m";
load "rank_0_auxiliary.m";
 
// These are files from the paper N. Ad≈æaga, T. Keller, P. Michaud-Jacobs, F. Najman, E. Ozman, B. Vukorepa, Computing quadratic points on modular curves X_0(N), Math. Comp. 93 (2024), 1371-1397. We use some auxilliary code, e.g. for computing the j-map, from there.

Qx<x>:=PolynomialRing(Rationals());
N:=72;
XN, ws, _, _, cuspInf := eqs_quos(N, []);
//pts:=PointSearch(X,100);

//pts := [ X ! a : a in pts];
//pls := [ Place(a) : a in pts];
jMap, num_denom := jmap(XN, N);
printf "Nice model for X_0(%o) is: %o\n\n", N, XN;
XN_Cusps := compute_cusps(XN, N, ws, cuspInf, num_denom);

ListOfDivs := [Q : Q in Divisors(N) | GCD(Q, ExactQuotient(N,Q)) eq 1 and Q ne 1];
wd := ws[Index(ListOfDivs, d)];
printf "w_%o on X_0(%o) is given by: %o\n", d, N, wd;
printf "Genus of X_0(%o) is %o\n", N, Genus(XN);
printf "We have found these %o cusps on X_0(%o):\n%o\n", #XN_Cusps, N, XN_Cusps;

//known degree 1 places
pls1 := [XN_Cusps[i] : i in [1..#XN_Cusps] | Degree(XN_Cusps[i]) eq 1];

//known degree 2 rational effective divisors
deg2 := [1*XN_Cusps[i] : i in [1..#XN_Cusps] | Degree(XN_Cusps[i]) eq 2];

cusps:=XN_Cusps;
cuspDegrees := [EulerPhi(GCD(m, N div m)) : m in Divisors(N)]; 
assert Sort(cuspDegrees) eq Sort([Degree(c) : c in cusps]); 
cusps1 := [P : P in cusps | Degree(P) eq 1];
assert #cusps1 ge 2; 
// There are always at least two cusps 
// of degree 1 corresponding to the
// factors 1 and N of N.
P0 := cusps1[1]; // This will be our base point for the Abel-Jacobi map.
cusps2:=[P : P in cusps | Degree(P) eq 2];
#cusps2; 


gensfp := function(Xp,divs)
//This function computes the set of generators of divisor classes supported on divisors in divs. It also returns the invariants of the generated group.
P0:=divs[1];
C,phi,psi:=ClassGroup(Xp);
Z:=FreeAbelianGroup(1);
degr:=hom<C->Z | [ Degree(phi(a))*Z.1 : a in OrderedGenerators(C)]>;
A:=Kernel(degr);
divs0:=[psi(D-Degree(D)*P0) : D in divs];
Ksub1:=sub<A | divs0>;
r:=#divs;
inds:=[i : i in [1..r]];
i:=r+1;
repeat
	i:=i-1;
	indsNew:=Exclude(inds,i);
	if sub<A | [divs0[j] : j in indsNew]> eq Ksub1 then
		inds:=indsNew;
	end if;
until i eq 1;
divsNew:=[divs0[j] : j in inds];
r:=#divsNew;	
Zr:=FreeAbelianGroup(r);
h:=hom<Zr->A | divsNew>;
Ksub:=Image(h);
assert Ksub eq Ksub1;
hf:=hom<Zr->Ksub | [ Ksub!h(Zr.i) :  i in [1..r] ]>;
bas:=[Eltseq(i@@hf) : i in OrderedGenerators(Ksub)];
divgen:=[phi(&+[d[i]*(divsNew[i]) : i in [1..#divsNew]]) : d in bas ];
return divgen, Invariants(Ksub);
end function;


procedure RRCheck(k, bounds, current, A, P0,~counter)
//This is a recursive function that runs through all the divisor classes in Pic^3 generated by divisor classes in A and counts the number contianing an effective divisor of degree 3. 

    if #current eq k then
        // Access the element at the current index tuple
        elem := 0*A[1];
        for i in [1..#current] do
			k:=current[i];
            elem := elem+(k*A[i]); 
        end for;

        // Check a condition
		D:=elem+3*P0;
		Degree(D);
        if IsEffective(D) then
			counter:=counter+1;
		else
			L,eta:=RiemannRochSpace(D);
			if Dimension(L) gt 0 then
				counter:=counter+1;
			end if;
		end if;
        return;
    end if;

    idx := #current + 1;
    for i in [1..bounds[idx]] do
        RRCheck(k, bounds, current cat [i], A,P0, ~counter);
    end for;
end procedure;

p:=5;
Xp:=ChangeRing(XN,GF(5));
cusps5:=[reduce(XN,Xp,D): D in cusps];
gens,invs:=gensfp(Xp,cusps5);
counter:=0;
current:=[];
P0:=cusps5[1];
assert(Degree(P0) eq 1);
RRCheck(#invs, invs, current, gens, P0, ~counter);
counter; // this is the number of effective divisors of degree 3

assert (counter eq Binomial(#cusps1+3-1,3)+#cusps1*#cusps2); //We prove that the number of effective degree 3 divisors over F_p is the same as the number of of cuspidal divisors, completing the proof.

